@version: 4.8
@include "scl.conf"		# Cisco、PaloAlto、Fortigate などのログのパースも含まれる

# RFC 5424  :  514/udp  514/tcp
# Cisco用   : 3514/udp 3514/tcp
# RFC 3164  : 4514/udp 4514/tcp
# fortigate : 5514/udp 5514/tcp
# fluent_bit から json 構造化ログ
#           : 6514/tcp
#
options {
  chain-hostnames(off); # ホスト名だけで送られてきたときドメイン名を補完しない
  use-dns(no); use-fqdn(no); dns-cache(no); keep-hostname(yes);
  create-dirs(yes); dir-perm(0755); perm(0644);

  frac-digits(6);	# 秒以下の桁数を指定
  ts-format(rfc3339);   # json 形式で出力するため多分無意味

  stats(freq(86400));
  threaded(yes);
};

#==================================
# 1. ソース (受信)
#==================================
# ---------------------------------------------------
# UDP/TCP 一般用 RFC 5424 用 改行区切り (514/udp,514/tcp)
# ---------------------------------------------------
source s_rfc5424 {
  network(ip(0.0.0.0) port(514) transport("udp") flags(syslog-protocol) log-msg-size(65536));
  network(ip(0.0.0.0) port(514) transport("tcp") flags(syslog-protocol) log-msg-size(65536));
};

# ---------------------------------------------------
# RFC 5424 octet-counted 用 (2514/tcp)
# ---------------------------------------------------
source s_rfc5424_octet {
  syslog(
    ip(0.0.0.0) port(2514) transport("tcp") flags(syslog-protocol) log-msg-size(65536) max-connections(100)
  );
};

# ---------------------------------------------------
# Cisco 機器専用 (3514/udp, 3514/tcp)
# ---------------------------------------------------
source s_cisco{
  # Cisco は独自形式で送信してくるため、flags(no-parse) を使用
  # cisco-parser() が全体をパースする
  network(ip(0.0.0.0) port(3514) transport("udp") flags(no-parse) log-msg-size(65536));
  network(ip(0.0.0.0) port(3514) transport("tcp") flags(no-parse) log-msg-size(65536));
};

# ---------------------------------------------------
# RFC 3164 (IXルーター等) 受信用 (4514/udp)
# ---------------------------------------------------
# flags(syslog-protocol) を*指定しない*
source s_rfc3164 {
  network(ip(0.0.0.0) port(4514) transport("udp") log-msg-size(65536));
  network(ip(0.0.0.0) port(4514) transport("tcp") log-msg-size(65536));
};
# ---------------------------------------------------
# TCP/UDP Fortigate 用 (5514/udp)
# ---------------------------------------------------
source s_fortigate {
  network(ip(0.0.0.0) port(5514) transport("udp") flags(no-parse) log-msg-size(65536));
  network(ip(0.0.0.0) port(5514) transport("tcp") flags(no-parse) log-msg-size(65536));
};

# ---------------------------------------------------
# JSON 構造化ログ受信用 Fluent-bit 等の出力を受ける (6514/tcp)
# ---------------------------------------------------
source s_fluent_bit {
  # Fluent-bit は RFC 5424 準拠なので syslog() のままでも可
  # network() に変更しても動作します
  network(ip(0.0.0.0) port(6514) flags(syslog-protocol) log-msg-size(65536));
};

#==================================
# 2. フィルタ (分類担当)
#==================================
# FortiGateのIPアドレスでフィルタリング
filter f_fortigate {
  host("192.168.0.254") or netmask("127.0.0.0/30");
};

#==================================
# 3. パーサー (項目の分解)
#==================================
# ---------------------------------------------------
# Cisco 専用パーサー (構造化データ + メッセージパース)
# ---------------------------------------------------
parser p_cisco {
  channel {
    # 1. 構造化データ部分を抽出（あればマッチ、なければスキップ）
    parser {
      regexp-parser(
        patterns(
          # パターン1: 構造化データあり (柔軟対応 - 任意のパラメータを許容) + seqあり
          '^\<(?<pri>[0-9]+)\>(?<seq1>[0-9]+): (?:(?<cisco_hostname>[^ ]+): )?\[syslog@9[^\]]+\]: (?<seq>[0-9]+): (?<remaining_msg>.*)',
          # パターン2: 構造化データあり (柔軟対応) + seqなし
          '^\<(?<pri>[0-9]+)\>(?<seq1>[0-9]+): (?:(?<cisco_hostname>[^ ]+): )?\[syslog@9[^\]]+\]: (?<remaining_msg>.*)',
          # パターン3: 構造化データ壊れ (]: だけ残っている) + ホスト名あり
          '^\<(?<pri>[0-9]+)\>(?<seq1>[0-9]+): (?:(?<cisco_hostname>[^ ]+): )?\]: (?<remaining_msg>.*)',
          # パターン4: 構造化データなし + ホスト名あり + seqあり
          '^\<(?<pri>[0-9]+)\>(?<seq1>[0-9]+): (?:(?<cisco_hostname>[^ ]+): )?(?<seq>[0-9]+): (?<remaining_msg>.*)',
          # パターン5: 構造化データなし + ホスト名あり (シンプル)
          '^\<(?<pri>[0-9]+)\>(?<seq1>[0-9]+): (?:(?<cisco_hostname>[^ ]+): )?(?<remaining_msg>.*)',
          # パターン6: priority なし (通常のCisco IOS形式)
          '^(?<seq1>[0-9]+): (?<remaining_msg>.*)'
        )
      );
    };
    # 2. MESSAGEを再設定
    rewrite {
      set("${remaining_msg}", value("MESSAGE"));
    };
    # 3. タイムスタンプ抽出とパース（失敗しても継続）
    # まずタイムスタンプとタイムゾーンを抽出
    parser {
      regexp-parser(
        patterns(
          # パターン1: 年あり + タイムゾーン名付き + ミリ秒あり (例: Nov  9 2025 22:23:49.895 UTC:)
          '^(?<cisco_timestamp>[A-Z][a-z]+ +[0-9]+ +[0-9]{4} +[0-9]+:[0-9]+:[0-9]+\.[0-9]+) +(?<cisco_tz>[A-Z]{2,5}): (?<cisco_msg_after_ts>.*)',
          # パターン2: 年あり + タイムゾーンなし + ミリ秒あり (例: Nov  9 2025 22:23:49.895:)
          '^(?<cisco_timestamp>[A-Z][a-z]+ +[0-9]+ +[0-9]{4} +[0-9]+:[0-9]+:[0-9]+\.[0-9]+): (?<cisco_msg_after_ts>.*)',
          # パターン3: 年あり + タイムゾーン名付き + ミリ秒なし (例: Nov  9 2025 22:28:40 UTC:)
          '^(?<cisco_timestamp>[A-Z][a-z]+ +[0-9]+ +[0-9]{4} +[0-9]+:[0-9]+:[0-9]+) +(?<cisco_tz>[A-Z]{2,5}): (?<cisco_msg_after_ts>.*)',
          # パターン4: 年あり + タイムゾーンなし + ミリ秒なし (例: Nov  9 2025 22:28:40:)
          '^(?<cisco_timestamp>[A-Z][a-z]+ +[0-9]+ +[0-9]{4} +[0-9]+:[0-9]+:[0-9]+): (?<cisco_msg_after_ts>.*)',
          # パターン5: 年なし + タイムゾーン名付き + ミリ秒あり (例: Nov 10 07:17:05.557 JST:)
          '^(?<cisco_timestamp>[A-Z][a-z]+ +[0-9]+ +[0-9]+:[0-9]+:[0-9]+\.[0-9]+) +(?<cisco_tz>[A-Z]{2,5}): (?<cisco_msg_after_ts>.*)',
          # パターン6: 年なし + タイムゾーンなし + ミリ秒あり (例: Nov 10 07:17:05.557:)
          '^(?<cisco_timestamp>[A-Z][a-z]+ +[0-9]+ +[0-9]+:[0-9]+:[0-9]+\.[0-9]+): (?<cisco_msg_after_ts>.*)',
          # パターン7: 年なし + タイムゾーン名付き + ミリ秒なし (例: Nov  9 22:19:15 JST:)
          '^(?<cisco_timestamp>[A-Z][a-z]+ +[0-9]+ +[0-9]+:[0-9]+:[0-9]+) +(?<cisco_tz>[A-Z]{2,5}): (?<cisco_msg_after_ts>.*)',
          # パターン8: 年なし + タイムゾーンなし + ミリ秒なし (例: Nov  9 22:19:15:)
          '^(?<cisco_timestamp>[A-Z][a-z]+ +[0-9]+ +[0-9]+:[0-9]+:[0-9]+): (?<cisco_msg_after_ts>.*)'
        )
        template("${MESSAGE}")
      );
    };
    # タイムスタンプが抽出できた場合のみパース
    if ("${cisco_timestamp}" ne "") {
      # タイムゾーンに応じて解釈を変更
      if ("${cisco_tz}" eq "JST") {
        parser {
          date-parser(
            format(
              "%b %d %Y %H:%M:%S.%f",
              "%b %d %Y %H:%M:%S",
              "%b %d %H:%M:%S.%f",
              "%b %d %H:%M:%S"
            )
            template("${cisco_timestamp}")
            time-zone("Asia/Tokyo")
          );
        };
      } elif ("${cisco_tz}" eq "UTC") {
        parser {
          date-parser(
            format(
              "%b %d %Y %H:%M:%S.%f",
              "%b %d %Y %H:%M:%S",
              "%b %d %H:%M:%S.%f",
              "%b %d %H:%M:%S"
            )
            template("${cisco_timestamp}")
            time-zone("UTC")
          );
        };
      } else {
        # タイムゾーン指定なし or その他のタイムゾーンはUTCとして扱う
        parser {
          date-parser(
            format(
              "%b %d %Y %H:%M:%S.%f",
              "%b %d %Y %H:%M:%S",
              "%b %d %H:%M:%S.%f",
              "%b %d %H:%M:%S"
            )
            template("${cisco_timestamp}")
            time-zone("UTC")
          );
        };
      };
      # タイムスタンプ以降のメッセージに置き換え
      rewrite {
        set("${cisco_msg_after_ts}", value("MESSAGE"));
      };
    };
    # 4. Cisco メッセージをパース（失敗しても継続）
    junction {
      channel {
        parser {
          cisco-parser();
        };
      };
      channel { };
    };
    # 5. HOSTを設定
    # Ciscoホスト名があればそれを使用、なければIPアドレスを使用
    rewrite {
      # まずIPアドレスを設定
      set("${HOST_FROM}", value("HOST"));
      # cisco_hostnameが存在すれば上書き
      set("${cisco_hostname}", value("HOST") condition("${cisco_hostname}" ne ""));
    };
    # 7. 不要なフィールドを削除
    rewrite {
      unset(value("remaining_msg"));
      unset(value("cisco_timestamp"));
      unset(value("cisco_msg_after_ts"));
      unset(value("cisco_hostname"));
      unset(value("seq1"));  # seq2があるので不要
      unset(value("pri"));   # facility と priority があるので不要
      unset(value("0"));
      unset(value("1"));
      unset(value("2"));
      unset(value("3"));
    };
  };
};

# シーケンス番号などの詳細情報も抽出したい場合は p_cisco_alt を使用
# parser p_cisco_alt {
#   channel {
#     # 構造化データを抽出
#     parser {
#       regexp-parser(
#         patterns('^\<(?<pri>[0-9]+)\>(?<seq1>[0-9]+): \[syslog@9 s_sn="(?<seq_num>[0-9]+)"\]: (?<seq2>[0-9]+): (?<remaining_msg>.*)')
#         flags(store-legacy-msghdr)
#       );
#     };
#     # Cisco メッセージ部分だけを MESSAGE として再設定
#     rewrite {
#       set("${remaining_msg}", value("MESSAGE"));
#       # ホスト名を正しく設定（元の送信元IPアドレスから）
#       set("${HOST_FROM}", value("HOST"));
#     };
#     # Cisco パーサーを適用
#     parser {
#       cisco-parser();
#     };
#     # 不要なフィールドを削除
#     rewrite {
#       unset(value("remaining_msg"));
#       unset(value("0"));
#       unset(value("1"));
#       unset(value("2"));
#       unset(value("3"));
#     };
#   };
# };

# ---------------------------------------------------
# FortiGateログ専用パーサー
# ---------------------------------------------------
parser p_fortigate {fortigate-parser();};

# ---------------------------------------------------
# JSON形形式を解釈するパーサー
# ---------------------------------------------------
parser p_json {json-parser();};

#==================================
# 4. 宛先 (送信)
#==================================
# OpenObserve に送る
destination d_openobserve {
  openobserve-log(
    persist_name("openobserve")
    url("http://OpenObserve")
    port(5080)
    organization("default")
    stream("syslog-ng")
    user("root@root.root")
    password("root")
    time-zone("Asia/Tokyo")

    # scl.conf のFortigateパーサーで追加された .fortigate.* フィールドの JSON 化に必要
    # 全ての名前-値ペアをJSON形式で送信、ログに含まれるタイムスタンプを追加
    record("--scope rfc5424 --scope all-nv-pairs --exclude DATE --key ISODATE @timestamp=${ISODATE}")

    disk-buffer(
      reliable(yes)
      mem-buf-size(1048576)      # メモリバッファサイズ: 1MB (一時的にメモリに保持するログのサイズ)
      disk-buf-size(104857600)   # ディスクバッファサイズ: 100MB (OpenObserveが停止時のログ保持用)
      dir("/buffer/to_OpenObserve/")
    )
    workers(4)
  );
};

# Cisco ログ専用ファイル出力
destination d_cisco_file {
  file(
    "/config/log/cisco.log"
    template("${ISODATE} ${HOST} ${MSGHDR}${MESSAGE}\n")
    ts-format(iso)
    time-zone("Asia/Tokyo")
    create-dirs(yes)
  );
};

# Cisco デバッグ用 - RAW メッセージを出力
destination d_cisco_raw {
  file(
    "/config/log/cisco_raw.log"
    template("RAW: ${RAWMSG}\nMSG: ${MESSAGE}\nSOURCE: ${SOURCE}\n---\n")
    create-dirs(yes)
  );
};

# json 構造化済みのログ用
destination d_openobserve_json {
  openobserve-log(
    persist_name("openobserve_json")
    url("http://OpenObserve")
    port(5080)
    organization("default")
    stream("syslog-ng")
    user("root@root.root")
    password("root")
    time-zone("Asia/Tokyo")

    # JSON 形式を指定
    body("${MESSAGE}")

    disk-buffer(
      reliable(yes)
      mem-buf-size(1048576)      # メモリバッファサイズ: 1MB (一時的にメモリに保持するログのサイズ)
      disk-buf-size(104857600)   # ディスクバッファサイズ: 100MB (OpenObserveが停止時のログ保持用)
      dir("/buffer/to_OpenObserve/")
    )
    workers(4)
  );
};

#==================================
# 5. ログ処理のパイプライン定義
#==================================
# ---------------------------------------------------
# json 構造化ログ受信用
# ---------------------------------------------------
log {
  source(s_fluent_bit);
  parser(p_json);
  destination(d_openobserve_json);
  flags(final); # ここで処理完了とし、以降のlogブロックに進まない
};

# ---------------------------------------------------
# YAMAHA RTX 用
# ---------------------------------------------------
filter f_old_yamaha {
  host(^192.168.99.99$) or
  host(^192.168.99.222$)   # RTX のアドレス
};

log {
  source(s_rfc5424);
  filter(f_old_yamaha);
  # PROGRAMとMESSAGEに分割されるので結合する
  rewrite {
    set("${PROGRAM} ${MESSAGE}", value("MESSAGE"));
    unset(value("PROGRAM"));
  };
  destination(d_openobserve);
  flags(final);
};

# ---------------------------------------------------
# Fortigate 用
# ---------------------------------------------------
log {
  source(s_fortigate);
  filter(f_fortigate);
  parser(p_fortigate);
  destination(d_openobserve);
  flags(final);               # ここで処理完了
};

# ---------------------------------------------------
# Cisco 機器専用パイプライン
# ---------------------------------------------------
log {
  source(s_cisco);
  destination(d_cisco_raw);   # デバッグ用: RAW メッセージ出力（パース前）
  parser(p_cisco);            # 構造化データ削除 + タイムスタンプ抽出 + cisco-parser
  destination(d_cisco_file);  # ファイル出力（パース後、正しい時刻）
  destination(d_openobserve); # OpenObserve へ送信
  flags(final);               # ここで処理完了
};

# ---------------------------------------------------
# それ以外の全てのログの処理
# RFC 3164/5424 用のログパイプライン
# ---------------------------------------------------
log {
  source(s_rfc3164);
  source(s_rfc5424);
  source(s_rfc5424_octet);
  destination(d_openobserve);
  flags(final);               # ここで処理完了
};

#==================================
# 6. syslog-ng 自身の動作ログは docker へ任せる
#==================================
source s_internal    { internal(); };
destination d_stdout { file("/dev/stdout"); };
filter f_warnings    { level(warning..emerg); };

log {
    source(s_internal);
    filter(f_warnings);
    destination(d_stdout);
    flags(final);
};
